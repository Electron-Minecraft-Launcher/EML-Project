# Authentication

> [!IMPORTANT]
> This chapter assumes you have followed the previous chapter [Frontend architecture](#5.1-frontend-architecture) and have a basic Electron setup. If you are looking for an API reference only, please refer to [Authentication](/api#authentication).

Authentication is the first barrier of your launcher. It ensures that only valid users can access the game and allows you to retrieve their Minecraft profile (UUID, Username, Skin).

In this section, we will implement the authentication flow using EML Lib within our Electron architecture.

## The logic (`main` process)

First, we need to create the IPC handlers that will perform the actual authentication logic securely in the Main process.

Create a new file `electron/handlers/auth.js` (or `.ts`) and add the following code. We will use the `MicrosoftAuth` class from EML Lib.

<!-- CODESWITCH:START -->

<!-- CODE:JavaScript -->

```javascript
const { ipcMain } = require('electron')
const { MicrosoftAuth } = require('eml-lib')

function registerAuthHandlers(mainWindow) {
  const auth = new MicrosoftAuth(mainWindow)

  // 1. LOGIN
  ipcMain.handle('auth:login', async () => {
    try {
      const account = await auth.auth()
      return { success: true, account }
    } catch (err) {
      console.error('[Auth] Login failed:', err)
      return { success: false, error: err.message ?? 'Unknown error' }
    }
  })

  // 2. REFRESH (Silent login)
  ipcMain.handle('auth:refresh', async (_, savedAccount) => {
    try {
      const isValid = await auth.validate(savedAccount)
      
      if (isValid) {
        return { success: true, account: savedAccount }
      } else {
        const newAccount = await auth.refresh(savedAccount)
        return { success: true, account: newAccount }
      }
    } catch (err) {
      console.error('[Auth] Refresh failed:', err)
      return { success: false, error: err.message }
    }
  })

  // 3. LOGOUT
  ipcMain.handle('auth:logout', async () => {
    return { success: true }
  })
}

module.exports = { registerAuthHandlers }
```

<!-- CODE:TypeScript -->

```typescript
import { ipcMain, BrowserWindow } from 'electron'
import { MicrosoftAuth } from 'eml-lib'
import type { Account } from 'eml-lib/dist/types/account'

export type IAuthResponse = { success: true; account: Account } | { success: false; error: string }

export function registerAuthHandlers(mainWindow: BrowserWindow) {
  const auth = new MicrosoftAuth(mainWindow)

  // 1. LOGIN
  ipcMain.handle('auth:login', async (): Promise<IAuthResponse> => {
    try {
      const account = await auth.auth()
      
      return { success: true, account }
    } catch (err: any) {
      console.error('[Auth] Login failed:', err)
      return { success: false, error: err.message ?? 'Unknown error' }
    }
  })

  // 2. REFRESH (Silent login)
  ipcMain.handle('auth:refresh', async (_, savedAccount: Account): Promise<IAuthResponse> => {
    try {
      const isValid = await auth.validate(savedAccount)
      
      if (isValid) {
        return { success: true, account: savedAccount }
      } else {
        const newAccount = await auth.refresh(savedAccount)
        return { success: true, account: newAccount }
      }
    } catch (err: any) {
      console.error('[Auth] Refresh failed:', err)
      return { success: false, error: err.message }
    }
  })

  // 3. LOGOUT
  ipcMain.handle('auth:logout', async () => {
    return { success: true }
  })
}
```

<!-- CODESWITCH:END -->

Now, register these handlers in your main entry point `electron/main.ts` (or `.js`):

<!-- CODESWITCH:START -->

<!-- CODE:JavaScript -->

```javascript
const { app, BrowserWindow } = require('electron')
const { registerAuthHandlers } = require('./handlers/auth')

let mainWindow = null

function createWindow() {
  mainWindow = new BrowserWindow({ /* ... config ... */ })
  
  // Register handlers, passing the window instance
  registerAuthHandlers(mainWindow)
  
  // ... load content ...
}

app.whenReady().then(createWindow)
```

<!-- CODE:TypeScript -->

```typescript
import { app, BrowserWindow } from 'electron'
import { registerAuthHandlers } from './handlers/auth'

let mainWindow: BrowserWindow | null = null

function createWindow() {
  mainWindow = new BrowserWindow({ /* ... config ... */ })
  
  // Register handlers, passing the window instance
  registerAuthHandlers(mainWindow)
  
  // ... load content ...
}

app.whenReady().then(createWindow)
```

<!-- CODESWITCH:END -->

## The bridge (preload & IPC)

Ensure your `electron/preload.js` (or `.ts`) script exposes these methods, as described in the previous chapter [Frontend architecture](#5.1-frontend-architecture).

If you followed the guide, you should already have:

<!-- CODESWITCH:START -->

<!-- CODE:JavaScript -->

```javascript
const { contextBridge, ipcRenderer } = require('electron')

contextBridge.exposeInMainWorld('api', {
  auth: {
    login: () => ipcRenderer.invoke('auth:login'),
    refresh: (account) => ipcRenderer.invoke('auth:refresh', account),
    logout: () => ipcRenderer.invoke('auth:logout')
  }
})
```

<!-- CODE:TypeScript -->

```typescript
import { contextBridge, ipcRenderer } from 'electron'

contextBridge.exposeInMainWorld('api', {
  auth: {
    login: () => ipcRenderer.invoke('auth:login'),
    refresh: (account) => ipcRenderer.invoke('auth:refresh', account),
    logout: () => ipcRenderer.invoke('auth:logout')
  }
})
```

<!-- CODESWITCH:END -->

Then, create a wrapper in `src/ipc.js` (or `.ts`) to call these methods easily:

<!-- CODESWITCH:START -->
<!-- CODE:JavaScript -->

```javascript
export const auth = {
  login: () => window.api.auth.login(),
  refresh: (account) => window.api.auth.refresh(account),
  logout: () => window.api.auth.logout()
}
```

<!-- CODE:TypeScript -->

```typescript
import type { IAuthResponse } from '../electron/handlers/auth'

declare global {
  interface Window {
    api: {
      auth: {
        login: () => Promise<IAuthResponse>
        refresh: () => Promise<IAuthResponse>
        logout: () => Promise<{ success: boolean }>
      }
    }
  }
}

export const auth = {
  login: async () => await window.api.auth.login(),
  logout: async () => await window.api.auth.logout(),
  refresh: async () => await window.api.auth.refresh()
}
```

<!-- CODESWITCH:END -->

## The interface (`renderer` process)

Now, let's connect the UI buttons to these actions.

### Triggering login

In your `src/views/login.js` (or `.ts`), handle the button click.

<!-- CODESWITCH:START -->

<!-- CODE:JavaScript -->

```javascript
const { setUser, setView } = require('../state') // Your state management
const { auth } = require('../ipc')

function initLogin() {
  const btn = document.getElementById('btn-login-ms')
  if (!btn) return

  btn.addEventListener('click', async () => {
    btn.disabled = true
    btn.innerHTML = 'Connecting...'

    try {
      const session = await auth.login()

      if (session.success) {
        setUser(session.account)
        setView('home')
      } else {
        console.error(session.error)
        alert('Login failed')
      }
    } catch (err) {
      console.error(err)
      alert('An error occurred during login.')
    } finally {
      btn.disabled = false
      btn.innerHTML = 'Log in with Microsoft'
    }
  })
}
```

<!-- CODE:TypeScript -->

```typescript
import { setUser, setView } from '../state'
import { auth } from '../ipc'

export function initLogin() {
  const btn = document.getElementById('btn-login-ms') as HTMLButtonElement | null
  if (!btn) return

  btn.addEventListener('click', async () => {
    btn.disabled = true
    btn.innerHTML = 'Connecting...'

    try {
      const session = await auth.login()

      if (session.success) {
        setUser(session.account)
        setView('home')
      } else {
        console.error(session.error)
        alert('Login failed')
      }
    } catch (err) {
      console.error(err)
      alert('An error occurred during login.')
    } finally {
      btn.disabled = false
      btn.innerHTML = 'Log in with Microsoft'
    }
  })
}
```

<!-- CODESWITCH:END -->

Don't forget to call `initLogin()` in you `src/app.js` (or `.ts`):

<!-- CODESWITCH:START -->

<!-- CODE:JavaScript -->

```javascript
const { initLogin } = require('./views/login')

initLogin()
```

<!-- CODE:TypeScript -->

```typescript
import { initLogin } from './views/login'

initLogin()
```

<!-- CODESWITCH:END -->

### Auto-login at startup

In your app entry point (e.g., `src/app.ts`), check if an account exists and is valid.

```typescript
import { auth } from './ipc'

async function initApp() {
  const savedJson = localStorage.getItem('user_account')
  
  if (savedJson) {
    const savedAccount = JSON.parse(savedJson)
    
    // Verify token validity with the Main process
    const response = await auth.refresh(savedAccount)
    
    if (response.success && response.account) {
      // Update local storage with potentially refreshed token
      localStorage.setItem('user_account', JSON.stringify(response.account))
      
      // Go directly to Home
      showHomeView()
      return
    }
  }
  
  // If no account or invalid, show Login
  showLoginView()
}

initApp()
```

## Alternative: Azuriom Authentication

If you use [Azuriom](https://azuriom.com/) for your website, you can use `AzAuth` instead of `MicrosoftAuth`.

Update your `electron/handlers/auth.ts`:

```typescript
import { AzAuth } from 'eml-lib'

// Inside registerAuthHandlers...
ipcMain.handle('auth:login-azuriom', async (_, { email, password, twoFactor }) => {
  const azAuth = new AzAuth('https://your-website.com')
  
  try {
    const account = await azAuth.auth(email, password, twoFactor)
    return { success: true, account }
  } catch (err: any) {
    // Handle 2FA requirement specific error code if needed
    if (err.code === 'TWOFA_CODE_REQUIRED') {
      return { success: false, error: '2FA_REQUIRED' }
    }
    return { success: false, error: err.message }
  }
})
```

## Alternative: Cracked Authentication

> [!CAUTION]
> This method is **insecure** and should only be used for development or testing purposes.

```typescript
import { CrackAuth } from 'eml-lib'

// Inside registerAuthHandlers...
ipcMain.handle('auth:login-crack', async (_, username) => {
  // CrackAuth is synchronous and simple
  const auth = new CrackAuth()
  const account = auth.auth(username)
  return { success: true, account }
})
```

---

## Reference: Authentication Classes

For advanced usage, here is a summary of the available methods in EML Lib classes.

**Constructor:** `new MicrosoftAuth(window, clientId?)`

| Method | Returns | Description |
| ---- | ---- | ---- |
| `auth()` | `Promise<Account>` | Opens login popup and returns account data. |
| `validate(account)` | `Promise<boolean>` | Checks if the token is still valid. |
| `refresh(account)` | `Promise<Account>` | Refreshes the access token. |

**Constructor:** `new AzAuth(url)`

| Method | Returns | Description |
| ---- | ---- | ---- |
| `auth(user, pass, 2fa?)` | `Promise<Account>` | Authenticates with email/password. |
| `verify(account)` | `Promise<Account>` | Verifies the session validity. |
| `logout(account)` | `void` | Logs out (server side). |