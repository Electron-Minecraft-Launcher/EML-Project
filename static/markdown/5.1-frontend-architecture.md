# Frontend architecture

Whether you are using our EML Template or building your launcher from scratch, the interface is the most important part for your players. It determines how they interact with your server.

This guide defines the recommended architecture, the necessary views to implement, and best practices for connecting your UI to the EML logic.

## Architecture guidelines

### The Single Page Application (SPA) model

We strongly recommend building your launcher as a **Single Page Application**.
Instead of having multiple HTML files (`login.html`, `home.html`) that cause a white flash when switching pages, you should have one single `index.html` file.

**How it works:**
* All "pages" (login, home, settings) are just `<div>` containers inside `index.html`.
* You use JavaScript (or CSS) to hide/show these containers to simulate navigation.
* **Benefit:** Instant transitions and a native app feel.

### Recommended tech stack

<!-- TABS:START -->

<!-- TABNAME:Using EML Template -->

EML Template is already configured with Vite, TypeScript, and SCSS.

* **Vite:** Handles the building and Hot Module Replacement (HMR). You see changes instantly.
* **SCSS:** The kit uses SCSS for styling. You will find variables for colors and fonts in `src/styles/_variables.scss`. Changing them there updates the whole theme.
* **TypeScript:** Ensures type safety when interacting with EML Lib types.

<!-- TABNAME:Building from Scratch -->

You are free to use any stack you like (React, Vue, Svelte, or Vanilla JS).

* **Styles:** We recommend using **SCSS** (Sass) or Tailwind CSS. Raw CSS can quickly become unmanageable for complex layouts.
* **Logic:** You can use plain JavaScript or TypeScript. TypeScript is recommended for better type safety, especially when working with EML Lib.

<!-- TABS:END -->

## Understanding IPC (Inter-Process Communication)

### The two-process model

This is the most critical concept to understand in Electron.

* **The UI (`renderer`):** This is your HTML/button. It _cannot_ download files or launch Java directly. It is sandboxed for security.
* **The logic (`main`):** This is where `EML Lib` runs. It has access to the disk and network.

**The flow:**
1. **`renderer`:** User clicks "Play".
2. **`renderer`:** Sends a message (`ipcRenderer.send('start-game')`) to the `main` process.
3. **`main`:** Receives the message, runs `launcher.launch()`, and sends back progress events.
4. **`renderer`:** Listens for progress (`ipcRenderer.on('progress')`) and updates the progress bar.

### Setting up IPC

<!-- TABS:START -->

<!-- TABNAME:Using EML Template -->

IPC is already set up in EML Template. Here is how it works:
* **Handler registration:** In `electron/handlers/`, you will find files that register IPC handlers for authentication, launcher actions, etc. The `registerXXXHandlers` functions are called in `electron/main.ts`.
* **Exposing to renderer:** In `electron/preload.ts`, IPC methods are exposed to the renderer via the `contextBridge`. The `src/ipc.ts` file wraps these methods for easy use in the UI.
* **Usage in views:** In your view logic files (e.g., `src/views/home.ts`), you can call these IPC methods to interact with EML Lib.

<!-- TABNAME:Building from Scratch -->

We recommend the following structure for setting up IPC:

1. **In the `main` process:**
   * Create a folder `electron/handlers/` to organize your IPC handlers.
   * For each feature (auth, launcher, settings), create a separate file (e.g., `auth.js`, `launcher.js`, or `auth.ts`, `launcher.ts` if using TypeScript).
   * In each file, define functions to register IPC handlers using `ipcMain.handle` or `ipcMain.on`.
   * In `electron/main.js`, import and call these registration functions.

2. Create `electron/preload.js` (or `electron/preload.ts` if using TypeScript) to expose IPC methods to the renderer using `contextBridge.exposeInMainWorld`. For example:

  <!-- CODESWITCH:START -->

  <!-- CODE:JavaScript -->

  ```javascript
  const { contextBridge, ipcRenderer } = require('electron')

  contextBridge.exposeInMainWorld('api', {
    auth: {
      login: () => ipcRenderer.invoke('auth:login'),
      refresh: () => ipcRenderer.invoke('auth:refresh'),
      logout: () => ipcRenderer.invoke('auth:logout')
    },
    // Other IPC methods...
  })
  ```

  <!-- CODE:TypeScript -->

  ```typescript
  import { contextBridge, ipcRenderer } from 'electron'
  import type { IAuthResponse } from './handlers/auth'

  contextBridge.exposeInMainWorld('api', {
    auth: {
      login: (): Promise<IAuthResponse> => ipcRenderer.invoke('auth:login'),
      refresh: (): Promise<IAuthResponse> => ipcRenderer.invoke('auth:refresh'),
      logout: (): Promise<{ success: boolean }> => ipcRenderer.invoke('auth:logout')
    },
    // Other IPC methods...
  })
  ```

  <!-- CODESWITCH:END -->
  
3. Create a wrapper file in the renderer (e.g., `src/ipc.js` or `src/ipc.ts`) to provide typed access to these methods. For example:

  <!-- CODESWITCH:START -->

  <!-- CODE:JavaScript -->

  ```javascript
  export const auth = {
    login: async () => await window.api.auth.login(),
    refresh: async () => await window.api.auth.refresh(),
    logout: async () => await window.api.auth.logout()
  }
  ```

  <!-- CODE:TypeScript -->

  ```typescript
  import type { IAuthResponse } from '../electron/handlers/auth'

  declare global {
    interface Window {
      api: {
        auth: {
          login: () => Promise<IAuthResponse>
          refresh: () => Promise<IAuthResponse>
          logout: () => Promise<{ success: boolean }>
        }
      }
    }
  }

  export const auth = {
    login: async () => await window.api.auth.login(),
    logout: async () => await window.api.auth.logout(),
    refresh: async () => await window.api.auth.refresh()
  }
  ```

  <!-- CODESWITCH:END -->

4. In your UI logic files (e.g., `src/views/home.js` or `src/views/home.ts`), import and use these IPC methods to interact with EML Lib.

<!-- TABS:END -->

## Best practices for code structure

If you are building from scratch, keeping your code organized is vital. Here is a recommended structure for a Vanilla JS/TS project (replace `.js` with `.ts` if using TypeScript):

```bash
/
├─ package.json
├─ vite.config.js
│
├─ electron/
│  ├─ main.js                     # Main process (EML Lib logic)
│  ├─ preload.js                  # Expose IPC methods to renderer (via ipc.ts)
│  └─ handlers/
│     ├─ auth.js                  # IPC handlers for authentication
│     ├─ launcher.js              # IPC handlers for launcher actions
│     └─ ...                      # Other IPC handlers
│
├─ src/
│  ├─ index.html                  # Single HTML file with all views
│  ├─ app.js                      # Core app logic
│  ├─ init.js                     # Initialize launcher (auto-login, ...)
│  ├─ ipc.ts                      # Expose IPC methods to renderer
│  ├─ state.js                    # State management (switching views, ...)                  
│  ├─ views/
│  │  ├─ login.js                 # Login logic (buttons, forms, ...)
│  │  ├─ home.js                  # Home logic
│  │  └─ ...
│  └─ static/
│     ├─ images/
│     │  ├─ logo.png              # Launcher logo
│     │  └─ ...                   # Other static images
│     └─ styles/
│        ├─ _variables.scss       # Global SCSS variables
│        ├─ main.scss             # Main stylesheet
│        ├─ login.scss            # Login view styles
│        └─ ...                   # Other view styles
│
└─ build/
   └─ icon.png
```

> [!TIP]
> If using EML Template, this structure is mostly already set up for you. If building from scratch, don't hesitate to look at EML Template code for inspiration.

## Designing the views

Here is the checklist of views (screens) you need to implement to handle all EML features.

> [!NOTE]
> Every feature below is documented in later chapters.

### Login view

This is the entry point.

<!-- TABS:START -->

<!-- TABNAME:Using EML Template -->

* **View:** `src/index.html`: `<div id="view-login" data-view="login">...</div>`.
* **Logic:** `src/views/login.ts`.
* **Style:** `src/static/styles/login.scss`.

By default, EML Template includes a basic login form with Microsoft authentication. Login view also includes a "Create account" link that opens Microsoft's account creation page.

<!-- TABNAME:From scratch -->

#### Components

* A sign-in form with:
  * a button for Microsoft authentication (recommended).
  * or a form for Azuriom authentication (username/password).
  * or a form for offline (cracked) authentication (username only).
  
  > [!IMPORTANT]
  > We strongly recommend using **Microsoft authentication** for security and ease of use. Avoid offline mode unless absolutely necessary.

* _(Optional)_ A "Create account" link that opens Microsoft's account creation page or your Azuriom registration page.

#### Best practice

* Show a loading spinner when the user clicks login.

* Disable buttons during authentication to prevent double-clicks.

<!-- TABS:END -->

### Home view

This is the main hub where players land after logging in.

<!-- TABS:START -->

<!-- TABNAME:Using EML Template -->

* **View:** `src/index.html`: `<div id="view-home" data-view="home">...</div>`.
* **Logic:** `src/views/home.ts`.
* **Style:** `src/static/styles/home.scss`.

EML Template includes a home view with:
* a "Play" button to start the game (with download progress).
* a news feed that fetches articles from EML AdminTool.
* a server status indicator showing online/offline and player count.
* a setting button to open settings.

<!-- TABNAME:From scratch -->

#### Components

* The "Play" button.

* A progress bar, hidden by default, visible during download/load.

* A progress label to show text like "Downloading assets...".

* _(Optional)_ A news feed container to display articles fetched from EML AdminTool.

* _(Optional)_ A server status indicator to display the player count (online/offline).

* _(Optional)_ A user profile section to display the player's skin head and username.

#### Best practices

* Disable or hide the "Play" button while downloading/launching to prevent multiple clicks.

* Update the progress bar and label in real-time based on events from EML Lib.

<!-- TABS:END -->

### Settings view

Allow users to tweak the launcher performance.

<!-- TABS:START -->

<!-- TABNAME:Using EML Template -->

Settings view is actually a modal overlay included in EML Template.

* **View:** `src/index.html`: `<div id="view-settings" data-view="settings">...</div>`.
* **Logic:** `src/views/settings.ts`.
* **Style:** `src/scss/views/settings.scss`.

EML Template includes settings for:
* RAM allocation sliders (min and max).
* Resolution dropdown.
* Java path selector.
* Launcher action after launch (minimize, close, do nothing).
* A "Logout" button.

<!-- TABNAME:From scratch -->

#### Components

* A "Logout" button that clears the auth token and returns to the login view.

* RAM allocation inputs (min and max).

* _(Optional)_ Resolution dropdown (list of common resolutions).

* _(Optional)_ Java path selector (file picker).

* _(Optional)_ Launcher action after launch (minimize, close, do nothing).

#### Best practices

* Validate RAM inputs to ensure min ≤ max and both are within reasonable limits.

* Show confirmation dialogs for critical actions like "Logout".

<!-- TABS:END -->

### Maintenance & Update views

These are "blocking" views. They should overlay everything else when active.

* **Maintenance:** Controlled by EML AdminTool. It should show the reason for maintenance and prevent access to the "Play" button.

* **Bootstrap Update:** When the launcher itself needs an update (managed by the _Bootstraps_ feature), this view should show a spinner or a download bar while the new version is being downloaded.

## Development tools

### Using DevTools

Since Electron is based on Chromium, you have access to the full Chrome DevTools.
* **Shortcut:** `Ctrl + Shift + I` (Windows/Linux) or `Cmd + Option + I` (macOS).
* Use the **Elements** tab to debug your CSS.
* Use the **Console** tab to see logs from the `renderer` process.

> [!NOTE]
> Logs from `EML Lib` (download progress, auth errors) usually appear in your **terminal** (where you ran `npm run dev`), not in the browser console, because they run in the `main` process. You need to forward them via IPC if you want to see them in the browser console.